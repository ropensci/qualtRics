#' Read a CSV file exported from Qualtrics
#'
#' Reads comma separated CSV files generated by Qualtrics
#' software. The second line containing the variable labels is imported.
#' Repetitive introductions to matrix questions are automatically removed.
#' Variable labels are stored as attributes.
#'
#' @param file_name String. A CSV data file.
#' @param import_id Logical. If \code{TRUE}, use Qualtrics import IDs instead of
#' question IDs as column names. Defaults to \code{FALSE}.
#' @param strip_html Logical. If \code{TRUE}, then remove HTML tags. Defaults
#' to \code{TRUE}.
#' @param time_zone String. A local timezone to determine response date
#' values. Defaults to \code{NULL} which corresponds to UTC time. See
#' \url{https://api.qualtrics.com/instructions/docs/Instructions/dates-and-times.md}
#' for more information on format.
#' @param colmap_attrs Logical. If \code{TRUE}, then attributes will be added to
#' each column in downloaded CSV providing info linking columns back to survey
#' question content obtainable using \code{metadata}. Defaults to \code{FALSE}.
#' @param legacy Logical. If \code{TRUE}, then import "legacy" format CSV files
#' (as of 2017). Defaults to \code{FALSE}.
#' @param col_types Optional. This argument provides a way to manually overwrite
#' column types that may be incorrectly guessed. Takes a \code{\link[readr]{cols}}
#' specification. See example below and \code{\link[readr]{cols}} for formatting
#' details. Defaults to \code{NULL}.
#'
#' @importFrom stats setNames
#' @importFrom sjlabelled set_label
#' @importFrom purrr map
#' @importFrom purrr imap
#' @importFrom purrr map_dfr
#' @importFrom tidyr unite
#' @importFrom tidyr everything
#' @importFrom stringr str_match
#' @importFrom readr read_csv
#' @importFrom readr locale
#' @importFrom readr type_convert
#' @importFrom dplyr select
#'
#' @return A data frame. Variable labels are stored as attributes. They are not
#' printed on the console but are visibile in the RStudio viewer.
#' @export
#' @examples
#' \dontrun{
#' # Generic use of read_survey()
#' df <- read_survey("<YOUR-PATH-TO-CSV-FILE>")
#' }
#' # Example using current data format
#' file <- system.file("extdata", "sample.csv", package = "qualtRics")
#' df <- read_survey(file)
#'
#' # Example using legacy data format
#' file <- system.file("extdata", "sample_legacy.csv", package = "qualtRics")
#' df <- read_survey(file, legacy = TRUE)
#'
#' # Example changing column type
#' file <- system.file("extdata", "sample.csv", package = "qualtRics")
#' # Force EndDate to be a string
#' df <- read_survey(file, col_types = readr::cols(EndDate = readr::col_character()))
#'
read_survey <- function(file_name,
                        strip_html = TRUE,
                        import_id = FALSE,
                        time_zone = NULL,
                        legacy = FALSE,
                        add_column_map = TRUE,
                        col_types = NULL) {


  # START UP: CHECK ARGUMENTS PASSED BY USER ----

  if (import_id & legacy) {
    warning("Using import IDs as column names are not supported for legacy CSVs. Defaulting to user-defined variable names; set import_id = FALSE in future.")
  }
  if (add_column_map & legacy) {
    warning("Column mapping can not be obtained from legacy CSVs. set colmap_attrs = FALSE in future.")
  }

  # check if file exists
  assert_surveyFile_exists(file_name)
  # skip 2 rows if legacy format, else 3 when loading the data
  skipNr <- ifelse(legacy, 2, 3)

  # Set time_zone to UTC if left unspecified
  if(is.null(time_zone)){
    time_zone <- "UTC"
  }

  # READ DATA ----

  # import raw data excluding variable names (row 1)
  # variable JSON (row 2, v3 only)
  # and descriptions (row 3, or 2 if legacy)
  rawdata <- suppressMessages(readr::read_csv(
    file = file_name,
    col_names = FALSE,
    col_types = readr::cols(.default = readr::col_character()),
    skip = skipNr,
    na = c("")
  ))

  # Load user-defined variable names + description:
  header <- suppressWarnings(suppressMessages(readr::read_csv(
    file = file_name,
    col_names = TRUE,
    col_types = readr::cols(.default = readr::col_character()),
    n_max = 1
  )))

  # Message for no data in survey
  if (nrow(rawdata) < 1) {
    message("The survey you are importing has no responses.")
    tbl <- tibble::as_tibble(matrix(nrow = 0,
                                    ncol = length(names(header))),
                             .name_repair = "minimal")
    colnames(tbl) <- names(header)
    tbl <- dplyr::mutate_all(tbl, as.character)
    return(tbl)
  }

  # MANIPULATE DATA ----

  # make them data.frame's, else the factor conversion
  # in `infer_data_types` crashes
  # rawdata <- as.data.frame(rawdata)
  # header <- as.data.frame(header)
  # Add names
  names(rawdata) <- names(header)

  # GET COLUMN MAPPING ------------------------------------------------------

  if(!legacy && (import_id || add_column_map)){

    col_map <-
      make_colmap(file_name = file_name,
                 qnames = names(header),
                 as_dataframe = TRUE
      )

    # Rename variables to be "ImportId_ChoiceId" rather than user-defined variable names:
    if (import_id) {

      qid_names <-
        tidyr::unite(qid_names_df,
                     col = qidnames,
                     c(ImportId, choiceId),
                     sep = "_",
                     na.rm = TRUE)[["qidnames"]]

      names(rawdata) <- qid_names

      if(add_column_map){

        # Swap the column map element names (qname) w/the internal QID (ImportID))
        col_map$qname <- qid_names

      }

    }

  }

  # If Qualtrics adds an empty column at the end, remove it
  if (grepl(",$", readLines(file_name, n = 1))) {
    header <- header[, 1:(ncol(header) - 1)]
    rawdata <- rawdata[, 1:(ncol(rawdata) - 1)]
  }

  # extract second row, remove it from df
  secondrow <- unlist(header)
  row.names(rawdata) <- NULL

  # Clean variable labels
  if (strip_html) {
    secondrow <- remove_html(secondrow)
  }

  # Scale Question with subquestion:
  # If it matches one of ".?!" followed by "-", take subsequent part
  subquestions <- stringr::str_match(secondrow, ".*[:punct:]\\s*-(.*)")[, 2]

  # Else if subquestion returns NA, use whole string
  subquestions[is.na(subquestions)] <- unlist(secondrow[is.na(subquestions)])

  # Remaining NAs default to 'empty string'
  subquestions[is.na(subquestions)] <- ""

  rawdata <- readr::type_convert(rawdata,
                                 locale = readr::locale(tz = time_zone),
                                 col_types = col_types)

  # Add descriptions to data as attribute "label"
  rawdata <- sjlabelled::set_label(rawdata, unlist(subquestions))

  if(!legacy && add_column_map){

    # Add decscriptive information:
    col_map$description <- unlist(subquestions)
    # Rearrange w/qname, descriptions, and then the rest:
    col_map <- dplyr::select(col_map, qname, description, tidyr::everything())
    # add to output as a data frame attribute:
    attr(rawdata, "column_map") <- col_map

  }

  # RETURN ----

  return(rawdata)
}
